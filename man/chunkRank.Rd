% Generated by roxygen2 (4.1.0.9000): do not edit by hand
% Please edit documentation in R/chunkRank.R
\name{chunkRank}
\alias{chunkRank}
\title{Chunk Indifferent Ranking Algorithm}
\usage{
chunkRank(lookup, predicted, ideal, cutoff = 100)
}
\arguments{
\item{lookup}{A vector of ints, with each int corresponding to the actual group assignment, and names(lookup) corresponding the unique id. If gold standard "ideal" is not provided, this variable will be sorted to derive the "ideal" gold standard [eg, 1 1 1 1 2 2 2 2... N]}

\item{predicted}{The predicted ordering, all labels in predicted must be present in lookup, and lengths must be equal}

\item{ideal}{The ideal gold standard ordering, increasing [eg, 1 1 1 1 2 2 2 2.. N]}

\item{cutoff}{The cutoff position for giving partial accuracy. This can be the number of images returned in the first pagination of an image search, the size of the first group (no partial accuracy given), or the length of the list (partial accuracy given for all) [default = 100]}
}
\description{
Calculates an accuracy for a ranked list of binary, monotonic groupings, "chunks" for which an ordering of the groups is desired, but no order of the elements within the groups is specified.  For example, if doing a query to return a list of results, we may want the first N to be of a particular type, but we don't care about the ordering within those first N. We may next want a group of type G, followed by R, and for both we are indifferent about the rankings within the groups. An accuracy is returned for each group, and it is up to the user to decide which to use, weighting, etc.
}
\examples{
### group assignment lookup [order doesn't matter, will be sorted increasing]
lookup = c(1,2,1,2,1,1,2,2,2,2,2,2,1,2,2,1)
names(lookup) = paste("n1",seq(1,length(lookup)),sep="")

### The predicted order
predicted = sample(names(lookup),length(lookup))
results = chunkRank(lookup,predicted)
}
\keyword{chunk}
\keyword{indifferent}
\keyword{ranking,}
\keyword{sorting}

